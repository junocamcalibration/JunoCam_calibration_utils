'''
This script reads in the netCDF file generated by create_databases.py and generates .npy
files for each crop. 

Note: This script also converts the image into an 8-bit integer from the original 16-bit.
'''
import netCDF4 as nc
import numpy as np
import glob
import tqdm
import os
from astropy.table import Table
import re
import cv2
import argparse
from params import Params
import itertools
import random


def len_nc(files):
    nfiles = 0
    for file in files:
        with nc.Dataset(file, 'r') as infile:
            nfiles += infile.dimensions['segment'].size
    dataset_name = files[0].split('/')[2]
    print(f'Found {nfiles} segments for {dataset_name} across {len(files)} files!')


def bytescaling(data, cmin=0, cmax=65535, high=255, low=0):
    """
    Converting the input image to uint8 or float32 dtype and scaling
    the range to ``(low, high)`` (default 0-255). If the input image already has 
    dtype uint8, no scaling is done.

    Equivalent to:
    # data = (data / 65536.0).astype('float32')
    without the scaling.
    Default input values assume data is 16-bit unsigned integer

    :param data: 16-bit image data array
    :param cmin: bias scaling of small values (def: data.min())
    :param cmax: bias scaling of large values (def: data.max())
    :param high: scale max value to high. (def: 255)
    :param low: scale min value to low. (def: 0)
    :return: 8-bit image data array
    """
    if data.dtype == np.uint8:
        return data

    if high > 255:
        high = 255
    if low < 0:
        low = 0
    if high < low:
        raise ValueError("`high` should be greater than or equal to `low`.")

    if cmin is None:
        cmin = data.min()
    if cmax is None:
        cmax = data.max()

    cscale = cmax - cmin
    if cscale == 0:
        cscale = 1

    scale = float(high - low) / float(cscale)
    bytedata = (data - cmin) * scale + low
    return bytedata.astype(np.float32)


def store_HST_segments(files, params, zone):

    hst_save_dir = params.hst_segments_dir + zone + "/"
    batch_size = params.batch_size

    # Initialize table for metadata
    table = Table(names=('index', 'latitude', 'longitude', 'rotation', 'cycle', 'filepath_npy', 'filepath_img'), dtype=(int, float, float, str, int, str, str))

    start = 0
    for file in files:
        
        print("File:", file)
        count = 0

        with nc.Dataset(file, 'r') as infile:
            imgs = infile.variables['img'][:].filled(fill_value=65535)
            IMG_H, IMG_W = imgs.shape[1], imgs.shape[2]

            # Check number of rotations. Cycle 27 only has one valid rotation
            n_rots = imgs.shape[4]

            filts = infile.filters
            cycle = re.findall(r'cycle([0-9]{2})', file)[0]
            
            outfolder_npys = hst_save_dir+"npy/"
            if not os.path.isdir(outfolder_npys):
                os.makedirs(outfolder_npys)

            if params.save_imgs:
                outfolder_imgs = hst_save_dir+"png/"
                outfolder_UV = hst_save_dir+"png_UV/"
                outfolder_M = hst_save_dir+"png_M/"
                if not os.path.isdir(outfolder_imgs):
                    os.makedirs(outfolder_imgs)
                if not os.path.isdir(outfolder_UV):
                    os.makedirs(outfolder_UV)
                if not os.path.isdir(outfolder_M):
                    os.makedirs(outfolder_M)

            lats = infile.variables['lat']
            lons = infile.variables['lon']

            f275w = filts.index('f275w')
            f395n = filts.index('f395n')
            f502n = filts.index('f502n')
            f631n = filts.index('f631n')
            fq889n = filts.index('fq889n')

            with tqdm.tqdm(range(infile.dimensions['segment'].size // batch_size + 1), ascii=True, desc=file) as pbar:
                for j in pbar:
                    
                    img_sub = imgs[j * batch_size: (j + 1) * batch_size, :]
                    img_sub = bytescaling(img_sub, high=1, low=0)
                    
                    lat_sub = np.asarray(lats[j * batch_size: (j + 1) * batch_size], dtype=float)
                    lon_sub = np.asarray(lons[j * batch_size: (j + 1) * batch_size], dtype=float)
                    nimgs = img_sub.shape[0] # batch_size

                    vis_imgs_rot_0 = np.zeros((img_sub.shape[0], 5, IMG_H, IMG_W), dtype=np.float32)
                    vis_imgs_rot_0[:, 0, :, :] = img_sub[:, :, :, f275w, 0]
                    vis_imgs_rot_0[:, 1, :, :] = img_sub[:, :, :, f395n, 0]
                    vis_imgs_rot_0[:, 2, :, :] = img_sub[:, :, :, f502n, 0]
                    vis_imgs_rot_0[:, 3, :, :] = img_sub[:, :, :, f631n, 0]
                    vis_imgs_rot_0[:, 4, :, :] = img_sub[:, :, :, fq889n, 0]

                    if n_rots > 1:
                        vis_imgs_rot_1 = np.zeros((img_sub.shape[0], 5, IMG_H, IMG_W), dtype=np.float32)
                        vis_imgs_rot_1[:, 0, :, :] = img_sub[:, :, :, f275w, 1]
                        vis_imgs_rot_1[:, 1, :, :] = img_sub[:, :, :, f395n, 1]
                        vis_imgs_rot_1[:, 2, :, :] = img_sub[:, :, :, f502n, 1]
                        vis_imgs_rot_1[:, 3, :, :] = img_sub[:, :, :, f631n, 1]
                        vis_imgs_rot_1[:, 4, :, :] = img_sub[:, :, :, fq889n, 1]

                    for i in range(nimgs): # batch
                        idx = start + count + i

                        filepath_npy_rot_0 = outfolder_npys + zone + '_cycle_' + str(cycle) + '_rot_A' + f'_hst_{idx:06d}'
                        np.save(filepath_npy_rot_0+".npy", vis_imgs_rot_0[i, :, :, :])
                        if n_rots > 1:                        
                            filepath_npy_rot_1 = outfolder_npys + zone + '_cycle_' + str(cycle) + '_rot_B' + f'_hst_{idx:06d}'
                            np.save(filepath_npy_rot_1+".npy", vis_imgs_rot_1[i, :, :, :])

                        if params.save_imgs:
                            bgr_0 = np.transpose(vis_imgs_rot_0[i, 1:4, :, :], (1, 2, 0))
                            filepath_img_rot_0 = outfolder_imgs + zone + '_cycle_' + str(cycle) + '_rot_A' + f'_hst_{idx:06d}'
                            cv2.imwrite(filepath_img_rot_0+".png", bgr_0*255.0)
                            # Save UV and Methane imgs
                            UV_0 = vis_imgs_rot_0[i, 0, :, :]
                            filepath_UV_rot_0 = outfolder_UV + zone + '_cycle_' + str(cycle) + '_rot_A' + f'_hst_UV_{idx:06d}'
                            cv2.imwrite(filepath_UV_rot_0+".png", UV_0*255.0)
                            M_0 = vis_imgs_rot_0[i, 4, :, :] * 5.0 # Methane needs to be scaled
                            filepath_M_rot_0 = outfolder_M + zone + '_cycle_' + str(cycle) + '_rot_A' + f'_hst_M_{idx:06d}'
                            cv2.imwrite(filepath_M_rot_0+".png", M_0*255.0)

                            if n_rots > 1:
                                bgr_1 = np.transpose(vis_imgs_rot_1[i, 1:4, :, :], (1, 2, 0))
                                filepath_img_rot_1 = outfolder_imgs + zone + '_cycle_' + str(cycle) + '_rot_B' + f'_hst_{idx:06d}'
                                cv2.imwrite(filepath_img_rot_1+".png", bgr_1*255.0)
                                # Save UV and Methane imgs for rot B
                                UV_1 = vis_imgs_rot_1[i, 0, :, :]
                                filepath_UV_rot_1 = outfolder_UV + zone + '_cycle_' + str(cycle) + '_rot_B' + f'_hst_UV_{idx:06d}'
                                cv2.imwrite(filepath_UV_rot_1+".png", UV_1*255.0)
                                M_1 = vis_imgs_rot_1[i, 4, :, :] * 5.0 # Methane needs to be scaled
                                filepath_M_rot_1 = outfolder_M + zone + '_cycle_' + str(cycle) + '_rot_B' + f'_hst_M_{idx:06d}'
                                cv2.imwrite(filepath_M_rot_1+".png", M_1*255.0)

                        else:
                            filepath_img_rot_0 = ''

                        # For now saving only rotation A metadata (rotation B ids correspond to the same lat/lon anyway...)
                        table.add_row((idx, lat_sub[i], lon_sub[i], 'A', cycle, os.path.realpath(filepath_npy_rot_0), filepath_img_rot_0))
                        if n_rots > 1:
                            table.add_row((idx, lat_sub[i], lon_sub[i], 'B', cycle, os.path.realpath(filepath_npy_rot_1), filepath_img_rot_1))

                    count += nimgs
                    pbar.set_postfix({'count': count, 'start': start})

        start += count

    table.write(hst_save_dir+'HST_metadata.csv', format='csv', overwrite=True)

    return table


def store_JVH_segments(files, params, zone):

    jvh_save_dir = params.jvh_segments_dir + zone + "/"
    batch_size = params.batch_size

    table = Table(names=('index', 'latitude', 'longitude', 'perijove', 'filepath_npy', 'filepath_img'), dtype=(int, float, float, int, str, str))

    start = 0
    for file in files:
        
        print("File:", file)
        count = 0

        with nc.Dataset(file, 'r') as infile:

            imgs = infile.variables['img'][:].filled(fill_value=65535)
            IMG_H, IMG_W = imgs.shape[1], imgs.shape[2]

            PJ = re.findall(r'PJ([0-9]{2})', file)[0]
            
            outfolder_npys = jvh_save_dir + 'npy/'
            if not os.path.isdir(outfolder_npys):
                os.makedirs(outfolder_npys)

            if params.save_imgs:
                outfolder_imgs = jvh_save_dir + 'png/'
                if not os.path.isdir(outfolder_imgs):
                    os.makedirs(outfolder_imgs)

            lats = infile.variables['lat']
            lons = infile.variables['lon']

            with tqdm.tqdm(range(infile.dimensions['segment'].size // batch_size + 1), ascii=True, desc=file) as pbar:
                for j in pbar:

                    img_sub = imgs[j * batch_size: (j + 1) * batch_size, :]
                    img_sub = bytescaling(img_sub, high=1, low=0)

                    lat_sub = np.asarray(lats[j * batch_size: (j + 1) * batch_size], dtype=float)
                    lon_sub = np.asarray(lons[j * batch_size: (j + 1) * batch_size], dtype=float)
                    nimgs = img_sub.shape[0] # batch_size

                    for i in range(nimgs): # batch
                        idx = start + count + i
                        filepath_npy = outfolder_npys + zone + '_PJ_' + PJ + f'_jc_{idx:06d}'

                        img_vis = np.asarray(img_sub[i,:,:,:,0]).astype(np.float32)
                        
                        np.save(filepath_npy+".npy", img_vis)

                        if params.save_imgs:
                            filepath_img = outfolder_imgs + zone + '_PJ_' + PJ + f'_jc_{idx:06d}'
                            cv2.imwrite(filepath_img+".png", img_vis*255.0)
                        
                        table.add_row((idx, lat_sub[i], lon_sub[i], PJ, filepath_npy, filepath_img))

                    count += nimgs
                    pbar.set_postfix({'count': count, 'start': start})
        start += count
    table.write(jvh_save_dir+'JVH_metadata.csv', format='csv', overwrite=True)

    return table



if __name__ == '__main__':

    parser = argparse.ArgumentParser(description=".")
    parser.add_argument("--batch_size", type=int, default=1, help="", required=False)
    parser.add_argument('--save_imgs', default=False, action='store_true', help='')
    parser.add_argument('--zones', nargs='+', default=["GRS"], help='Which zone to use. The corresponding lats are defined in params.py')
    args = parser.parse_args()

    params = Params(args)
    

    for zone in params.zones:

        # Collect all NC files for HST and JVH 
        # There should be NC files of all (or a subset) cycles/perijoves for that particular zone
        hst_nc_files = sorted(glob.glob(params.hst_nc_dir+'/cycle*_rot_'+zone+'.nc'))
        jvh_nc_files = sorted(glob.glob(params.jvh_nc_dir+'/PJ*_'+zone+'.nc'))

        if (len(hst_nc_files)==0) and (len(jvh_nc_files)==0):
            print("Could not find NC files for either HST or JVH zone", zone, ". Skipping ...")
            continue
        
        if len(hst_nc_files) > 0:
            len_nc(hst_nc_files)
            hst_segment_info = store_HST_segments(hst_nc_files, params, zone)
        if len(jvh_nc_files) > 0:
            len_nc(jvh_nc_files)
            jvh_segment_info = store_JVH_segments(jvh_nc_files, params, zone)
